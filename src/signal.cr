lib LibC
  fun signal(sig : Int32, handler : Int32 ->)
end

module Signal
  extend self

  EXIT   =  0
  HUP    =  1
  INT    =  2
  QUIT   =  3
  ILL    =  4
  TRAP   =  5
  IOT    =  6
  ABRT   =  6
  EMT    =  7
  FPE    =  8
  KILL   =  9
  BUS    = 10
  SEGV   = 11
  SYS    = 12
  PIPE   = 13
  ALRM   = 15
  TERM   = 15
  URG    = 16
  STOP   = 17
  TSTP   = 18
  CONT   = 19
  CHLD   = 20
  CLD    = 20
  TTIN   = 21
  TTOU   = 22
  IO     = 23
  XCPU   = 24
  XFSZ   = 25
  VTLARM = 26
  PROF   = 27
  WINCH  = 28
  INFO   = 29
  USR1   = 30
  USR2   = 31

  DEFAULT = Proc(Int32, Void).new(Pointer(Void).new(0_u64), Pointer(Void).null)
  IGNORE  = Proc(Int32, Void).new(Pointer(Void).new(1_u64), Pointer(Void).null)

  def trap(signal, block : Int32 ->)
    trap signal, &block
  end

  def trap(signal, &block : Int32 ->)
    if block.closure?
      handlers = @@handlers ||= {} of Int32 => Int32 ->
      handlers[signal] = block
      LibC.signal signal, ->handler(Int32)
    else
      LibC.signal signal, block
    end
  end

  protected def handler(num)
    @@handlers.not_nil![num]?.try &.call(num)
  end

  trap(PIPE, IGNORE)
end
